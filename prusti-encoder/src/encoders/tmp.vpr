// -----------------------------
// methods
// -----------------------------
method m_apply_id_rec_s_CALLER_(
_0p: Ref,
_1p: Ref,
_2p: Ref
)
requires p_Vector(_1p)
requires p_Int_i32(_2p)
ensures p_Vector(_0p)
ensures s_Bool_read_0((let _0_1s_0 == (old(p_Vector_snap(_1p))) in
(let _0_2s_0 == (old(p_Int_i32_snap(_2p))) in
(let _0_3s_0 == (p_Vector_snap(_0p)) in
(let _0_5s_1 == (s_0_Tuple_cons()) in
(let _0_6s_1 == (s_2_Tuple_cons(_0_3s_0, _0_1s_0)) in
(let _0_4s_1 == (s_Bool_cons(forall qvar_0_0: s_Int_i32 :: s_Bool_read_0((let _1_1s_0 == (_0_6s_1) in
(let _1_2s_0 == (qvar_0_0) in
(let _1_5s_1 == (s_2_Tuple_read_0(_1_1s_0)) in
(let _1_6s_1 == (_1_2s_0) in
(let _1_4s_1 == (f_get(_1_5s_1, _1_6s_1)) in
(let _1_3s_1 == (s_Ref_Not_cons(_1_4s_1)) in
(let _1_10s_1 == (s_2_Tuple_read_1(_1_1s_0)) in
(let _1_11s_1 == (_1_2s_0) in
(let _1_9s_1 == (f_get(_1_10s_1, _1_11s_1)) in
(let _1_8s_1 == (s_Ref_Not_cons(_1_9s_1)) in
(let _1_7s_1 == (s_Ref_Not_cons(s_Ref_Not_read_0(_1_8s_1))) in
(let _1_0s_0 == (s_Bool_cons((_1_3s_1) == (_1_7s_1))) in
_1_0s_0))))))))))))))) in
(let _0_0s_0 == (_0_4s_1) in
_0_0s_0))))))))
{
label start
goto bb_0
label bb_0
// _0 = move _1
var _tmp0: s_Vector
_tmp0 := p_Vector_snap(_1p)
exhale p_Vector(_1p)
assign_p_Vector(_0p, _tmp0)
// return
exhale p_Int_i32(_2p)
goto end
label end
// return
}

method m_main_CALLER_(
_0p: Ref
)
ensures p_0_Tuple(_0p)
{
label start
goto bb_0
label bb_0
// _0 = const ()
assign_p_0_Tuple(_0p, s_0_Tuple_cons())
// return
goto end
label end
// return
}

// -----------------------------
// functions
// -----------------------------
function f_get(
_1p: s_Vector,
_2p: s_Int_i32
): s_Int_i32

// -----------------------------
// MIR builtins
// -----------------------------
// -----------------------------
// generics
// -----------------------------
// -----------------------------
// snapshots
// -----------------------------
domain s_Int_i32 {
axiom ax_s_Int_i32_cons_read_0 {
forall f0: Int :: {s_Int_i32_cons(f0)} (s_Int_i32_read_0(s_Int_i32_cons(f0))) == (f0)
}
axiom ax_s_Int_i32_cons {
forall self: s_Int_i32 :: {s_Int_i32_read_0(self)} (s_Int_i32_cons(s_Int_i32_read_0(self))) == (self)
}
axiom ax_s_Int_i32_write_0_read_0 {
forall self: s_Int_i32, val: Int :: {s_Int_i32_read_0(s_Int_i32_write_0(self, val))} (s_Int_i32_read_0(s_Int_i32_write_0(self, val))) == (val)
}
axiom s_Int_i32_bounds {
forall self: s_Int_i32 :: {s_Int_i32_read_0(self)} ((-(2147483648)) <= (s_Int_i32_read_0(self))) && ((s_Int_i32_read_0(self)) <= (2147483647))
}
function s_Int_i32_cons(Int): s_Int_i32
function s_Int_i32_read_0(s_Int_i32): Int
function s_Int_i32_write_0(s_Int_i32, Int): s_Int_i32
}

domain s_Vector {
axiom ax_s_Vector_cons_read_0 {
forall f0: s_Int_i32, f1: s_Int_i32 :: {s_Vector_cons(f0, f1)} (s_Vector_read_0(s_Vector_cons(f0, f1))) == (f0)
}
axiom ax_s_Vector_cons_read_1 {
forall f0: s_Int_i32, f1: s_Int_i32 :: {s_Vector_cons(f0, f1)} (s_Vector_read_1(s_Vector_cons(f0, f1))) == (f1)
}
axiom ax_s_Vector_cons {
forall self: s_Vector :: {s_Vector_cons(s_Vector_read_0(self), s_Vector_read_1(self))} (s_Vector_cons(s_Vector_read_0(self), s_Vector_read_1(self))) == (self)
}
axiom ax_s_Vector_write_0_read_0 {
forall self: s_Vector, val: s_Int_i32 :: {s_Vector_read_0(s_Vector_write_0(self, val))} (s_Vector_read_0(s_Vector_write_0(self, val))) == (val)
}
axiom ax_s_Vector_write_0_read_1 {
forall self: s_Vector, val: s_Int_i32 :: {s_Vector_read_1(s_Vector_write_0(self, val))} (s_Vector_read_1(s_Vector_write_0(self, val))) == (s_Vector_read_1(self))
}
axiom ax_s_Vector_write_1_read_0 {
forall self: s_Vector, val: s_Int_i32 :: {s_Vector_read_0(s_Vector_write_1(self, val))} (s_Vector_read_0(s_Vector_write_1(self, val))) == (s_Vector_read_0(self))
}
axiom ax_s_Vector_write_1_read_1 {
forall self: s_Vector, val: s_Int_i32 :: {s_Vector_read_1(s_Vector_write_1(self, val))} (s_Vector_read_1(s_Vector_write_1(self, val))) == (val)
}
function s_Vector_cons(s_Int_i32, s_Int_i32): s_Vector
function s_Vector_read_0(s_Vector): s_Int_i32
function s_Vector_write_0(s_Vector, s_Int_i32): s_Vector
function s_Vector_read_1(s_Vector): s_Int_i32
function s_Vector_write_1(s_Vector, s_Int_i32): s_Vector
}

domain s_Bool {
axiom ax_s_Bool_cons_read_0 {
forall f0: Bool :: {s_Bool_cons(f0)} (s_Bool_read_0(s_Bool_cons(f0))) == (f0)
}
axiom ax_s_Bool_cons {
forall self: s_Bool :: {s_Bool_cons(s_Bool_read_0(self))} (s_Bool_cons(s_Bool_read_0(self))) == (self)
}
axiom ax_s_Bool_write_0_read_0 {
forall self: s_Bool, val: Bool :: {s_Bool_read_0(s_Bool_write_0(self, val))} (s_Bool_read_0(s_Bool_write_0(self, val))) == (val)
}
function s_Bool_cons(Bool): s_Bool
function s_Bool_read_0(s_Bool): Bool
function s_Bool_write_0(s_Bool, Bool): s_Bool
}

domain s_0_Tuple {
function s_0_Tuple_cons(): s_0_Tuple
}

domain s_2_Tuple[T0, T1] {
axiom ax_s_2_Tuple_cons_read_0 {
forall f0: T0, f1: T1 :: {s_2_Tuple_cons(f0, f1)} (s_2_Tuple_read_0(s_2_Tuple_cons(f0, f1))) == (f0)
}
axiom ax_s_2_Tuple_cons_read_1 {
forall f0: T0, f1: T1 :: {s_2_Tuple_cons(f0, f1)} (s_2_Tuple_read_1(s_2_Tuple_cons(f0, f1))) == (f1)
}
axiom ax_s_2_Tuple_cons {
forall self: s_2_Tuple[T0, T1] :: {s_2_Tuple_cons(s_2_Tuple_read_0(self), s_2_Tuple_read_1(self))} (s_2_Tuple_cons(s_2_Tuple_read_0(self), s_2_Tuple_read_1(self))) == (self)
}
axiom ax_s_2_Tuple_write_0_read_0 {
forall self: s_2_Tuple[T0, T1], val: T0 :: {s_2_Tuple_read_0(s_2_Tuple_write_0(self, val))} (s_2_Tuple_read_0(s_2_Tuple_write_0(self, val))) == (val)
}
axiom ax_s_2_Tuple_write_0_read_1 {
forall self: s_2_Tuple[T0, T1], val: T0 :: {s_2_Tuple_read_1(s_2_Tuple_write_0(self, val))} (s_2_Tuple_read_1(s_2_Tuple_write_0(self, val))) == (s_2_Tuple_read_1(self))
}
axiom ax_s_2_Tuple_write_1_read_0 {
forall self: s_2_Tuple[T0, T1], val: T1 :: {s_2_Tuple_read_0(s_2_Tuple_write_1(self, val))} (s_2_Tuple_read_0(s_2_Tuple_write_1(self, val))) == (s_2_Tuple_read_0(self))
}
axiom ax_s_2_Tuple_write_1_read_1 {
forall self: s_2_Tuple[T0, T1], val: T1 :: {s_2_Tuple_read_1(s_2_Tuple_write_1(self, val))} (s_2_Tuple_read_1(s_2_Tuple_write_1(self, val))) == (val)
}
function s_2_Tuple_cons(T0, T1): s_2_Tuple[T0, T1]
function s_2_Tuple_read_0(s_2_Tuple[T0, T1]): T0
function s_2_Tuple_write_0(s_2_Tuple[T0, T1], T0): s_2_Tuple[T0, T1]
function s_2_Tuple_read_1(s_2_Tuple[T0, T1]): T1
function s_2_Tuple_write_1(s_2_Tuple[T0, T1], T1): s_2_Tuple[T0, T1]
}

domain s_Never {
}

domain s_Ref_Not[T] {
axiom ax_s_Ref_Not_cons_read_0 {
forall f0: T :: {s_Ref_Not_cons(f0)} (s_Ref_Not_read_0(s_Ref_Not_cons(f0))) == (f0)
}
axiom ax_s_Ref_Not_cons {
forall self: s_Ref_Not[T] :: {s_Ref_Not_cons(s_Ref_Not_read_0(self))} (s_Ref_Not_cons(s_Ref_Not_read_0(self))) == (self)
}
axiom ax_s_Ref_Not_write_0_read_0 {
forall self: s_Ref_Not[T], val: T :: {s_Ref_Not_read_0(s_Ref_Not_write_0(self, val))} (s_Ref_Not_read_0(s_Ref_Not_write_0(self, val))) == (val)
}
function s_Ref_Not_cons(T): s_Ref_Not[T]
function s_Ref_Not_read_0(s_Ref_Not[T]): T
function s_Ref_Not_write_0(s_Ref_Not[T], T): s_Ref_Not[T]
}

// -----------------------------
// types
// -----------------------------
field f_Int_i32: s_Int_i32
function p_Int_i32_unreachable(
): s_Int_i32
requires false
ensures false

function p_Int_i32_snap(
self: Ref
): s_Int_i32
requires acc(p_Int_i32(self), wildcard)
{
unfolding acc(p_Int_i32(self), wildcard) in (self.f_Int_i32)
}

predicate p_Int_i32(self: Ref) {
acc(self.f_Int_i32)
}

method assign_p_Int_i32(
self: Ref,
self_new: s_Int_i32
)
ensures p_Int_i32(self)
ensures (p_Int_i32_snap(self)) == (self_new)

function p_Vector_field_0(
self: Ref
): Ref
ensures ((self) == (null)) == ((result) == (null))
function p_Vector_field_1(
self: Ref
): Ref
ensures ((self) == (null)) == ((result) == (null))
function p_Vector_unreachable(
): s_Vector
requires false
ensures false

function p_Vector_snap(
self: Ref
): s_Vector
requires acc(p_Vector(self), wildcard)
{
unfolding acc(p_Vector(self), wildcard) in (s_Vector_cons(p_Int_i32_snap(p_Vector_field_0(self)), p_Int_i32_snap(p_Vector_field_1(self))))
}

predicate p_Vector(self: Ref) {
(p_Int_i32(p_Vector_field_0(self))) && (p_Int_i32(p_Vector_field_1(self)))
}

method assign_p_Vector(
self: Ref,
self_new: s_Vector
)
ensures p_Vector(self)
ensures (p_Vector_snap(self)) == (self_new)

field f_Bool: s_Bool
function p_Bool_unreachable(
): s_Bool
requires false
ensures false

function p_Bool_snap(
self: Ref
): s_Bool
requires acc(p_Bool(self), wildcard)
{
unfolding acc(p_Bool(self), wildcard) in (self.f_Bool)
}

predicate p_Bool(self: Ref) {
acc(self.f_Bool)
}

method assign_p_Bool(
self: Ref,
self_new: s_Bool
)
ensures p_Bool(self)
ensures (p_Bool_snap(self)) == (self_new)

function p_0_Tuple_unreachable(
): s_0_Tuple
requires false
ensures false

function p_0_Tuple_snap(
self: Ref
): s_0_Tuple
requires acc(p_0_Tuple(self), wildcard)
{
unfolding acc(p_0_Tuple(self), wildcard) in (s_0_Tuple_cons())
}

predicate p_0_Tuple(self: Ref) {
true
}

method assign_p_0_Tuple(
self: Ref,
self_new: s_0_Tuple
)
ensures p_0_Tuple(self)
ensures (p_0_Tuple_snap(self)) == (self_new)

function p_Never_unreachable(
): s_Never
requires false
ensures false

function p_Never_snap(
self: Ref
): s_Never
requires acc(p_Never(self), wildcard)

predicate p_Never(self: Ref) {
false
}

method assign_p_Never(
self: Ref,
self_new: s_Never
)
ensures p_Never(self)
ensures (p_Never_snap(self)) == (self_new)